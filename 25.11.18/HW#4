// 4) Напишите программу находящую первые n составных чисел. Программа должна работать не более чем за O(n*log log n) шагов. 

#include "pch.h"
#include <iostream>
using namespace std;

int main()
{
	int lenN, i, j, cntSimple, cntMulti, minDiv;
	bool isSimpl;

	setlocale(LC_ALL, "Rus");
	cout << "Введите количество составных чисел: " << endl;
	cin >> lenN;
	if (lenN < 1) { 
		cout << "Неверное количество составных чисел. Стоп программа..." << endl;
		return 0;
	}
	// резервируем память под простые числа. Т.к. из N составных чисел половина четные, а для нечетных число простых делителей не превысит превысит N/2 + 2.
	int *ptrSm = new int[(lenN / 2) + 2]; 

	ptrSm[0] = 2; // 1 простое число, к тому же четное. Дальнейшие - нечетные
	cntSimple = 1;
	cntMulti = 0;
	i = 3;
	// Проверять четные смысла нет, поэтому цикл только по нечетным 
	while (true) {
		if ((i - 1) > 2) { // т.к. 2 единственное четное простое, а мы проскакиваем четные, то сначала кроме 2 наращиваем счетчик составных чисел
			cntMulti++; 
			cout << "Составное число " << cntMulti << ": " << (i - 1) << " (мин.делитель 2)" << endl;
			if (cntMulti == lenN) { break; } // прерываем цикл, т.к. нашли нужное число составных чисел
		}

		isSimpl = true;
		minDiv = 1;
		for (j = 0; j < cntSimple; j++) { // проверка на делимость на на запомненные простые числа из массива 
			if (i % ptrSm[j] == 0) {
				minDiv = ptrSm[j];
				isSimpl = false;
				break;
			}
		}
		if (isSimpl) { // если простое - дополняем массив простых чисел
			cntSimple++;
			ptrSm[cntSimple - 1] = i;
		}
		else { // число составное
			cntMulti++;
			cout << "Составное число " << cntMulti << ": " << i << " (мин.делитель " << minDiv << ")" << endl;
			if (cntMulti == lenN) { break; } // прерываем цикл, т.к. нашли нужное число составных чисел
		}

		i = i + 2; // дальше скачем по нечетным
	}

	delete[] ptrSm;
	return 0;
}
