/* 1) Напишите программу, находящую корни уравнения 2018X + 2019Y = 78487894 эффективным перебором.
В комментариях напишите, почему перебор - эффективный */

#include "pch.h"
#include <iostream>
using namespace std;

int main()
{	/* Решение ишем только в области положительных X и Y. 
	Для отрицательных X, Y - решений нет (что очевидно).
	Для X, Y с разными знаками - бесконечное число решений.
	В зависимости от min(X,Y) преобразуем уравнение: 
	Для X > Y уравнение имеет вид: (2018+2019)*Y + 2018*(X-Y) = 78487894
	Для X <= Y уравнение имеет вид: (2018+2019)*X + 2019*(Y-X) = 78487894
	Почему эффективный алгоритм? Мы укорачиваем перебор до количества шагов: 78487894 / (2018+2019).
	На каждом шаге проверяем на целочисленное деление остатка на 2018 и 2019
	*/
	int i, vI, maxStep, sum2000, cntAnsw, valX, valY;

	setlocale(LC_ALL, "Rus");

	sum2000 = 2018 + 2019;
	maxStep = 78487894 / sum2000;
	cntAnsw = 0;

	for (i = 0; i <= maxStep; i++) {
		vI = 78487894 - sum2000 * i;
		if (vI % 2018 == 0) { // Для X > Y
			if ((vI / 2018) > 0) { // доп.проверка на X > Y, т.е. (X - Y) > 0, чтоб не было дубликатов со 2 вариантом X <= Y
				cntAnsw++;
				valY = i;
				valX = valY + vI / 2018;
				cout << "Решение " << cntAnsw << ":  X = " << valX << "  Y = " << valY << endl;
			}
		}
		if (vI % 2019 == 0) { // Для X <= Y
			cntAnsw++;
			valX = i;
			valY = valX + vI / 2019;
			cout << "Решение " << cntAnsw << ":  X = " << valX << "  Y = " << valY << endl;
		}
	}

	return 0;
}
